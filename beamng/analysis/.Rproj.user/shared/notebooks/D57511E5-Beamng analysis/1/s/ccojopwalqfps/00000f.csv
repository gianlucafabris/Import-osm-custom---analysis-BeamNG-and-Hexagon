"0","reticulate::repl_python()"
"0","import numpy as np"
"0","import math"
"0","import matplotlib.pyplot as plt"
"0","from beamngpy import Scenario, Road, MeshRoad"
"0","import os"
"0","import json"
"0",""
"0","def visualizeCatmullrom(p):"
"0","    res = 100"
"0","    p_interpolated = catmull_rom(p, res)"
"0","    p = np.array(p)"
"0","    pmin = np.min(p) - 5"
"0","    pmax = np.max(p) + 5"
"0","    plt.figure(figsize=(10, 10))"
"0","    plt.plot(p_interpolated[:, 0], p_interpolated[:, 1])"
"0","    plt.scatter(p[:, 0], p[:, 1], color='black')"
"0","    plt.xlabel('X')"
"0","    plt.ylabel('Y')"
"0","    plt.xlim([pmin, pmax])"
"0","    plt.ylim([pmin, pmax])"
"0","    plt.grid(True)"
"0","    plt.show()"
"0","    "
"0","def catmull_rom_one_point(P0, P1, P2, P3, res = 100, alpha = 0.0):"
"0","    """""""
"0","    Computes interpolated y-coord for given x-coord using Catmull-Rom."
"0","    Computes an interpolated y-coordinate for the given x-coordinate between"
"0","    the support points P1 and P2. The neighboring support points P0 and P3 are"
"0","    used by Catmull-Rom to ensure a smooth transition between the spline"
"0","    segments."
"0","    This version works both with in x and y direction."
"0","    Args:"
"0","        P0: 1st support point"
"0","        P1: 2nd support point"
"0","        P2: 3rd support point"
"0","        P3: 4th support point"
"0","        res: resolution of a segment (including the start point, but not the endpoint of the segment)"
"0","        alpha: 0.0 uniform, 0.5 centripetal, 1.0 chordal"
"0","    Returns:"
"0","        y: value of y (given x) in that derivative"
"0","    """""""
"0","    def compute_tk(ti, pi, pj):"
"0","        return ti + (math.sqrt((pj[0] - pi[0])**2 + (pj[1] - pi[1])**2))**alpha"
"0","        "
"0","    t0 = 0.0"
"0","    t1 = compute_tk(t0, P0, P1)"
"0","    t2 = compute_tk(t1, P1, P2)"
"0","    t3 = compute_tk(t2, P2, P3)"
"0","    "
"0","    t = np.linspace(t1, t2, res, endpoint=False).reshape(res, 1)"
"0","    "
"0","    A1 = (t1 - t) / (t1 - t0) * P0 + (t - t0) / (t1 - t0) * P1"
"0","    A2 = (t2 - t) / (t2 - t1) * P1 + (t - t1) / (t2 - t1) * P2"
"0","    A3 = (t3 - t) / (t3 - t2) * P2 + (t - t2) / (t3 - t2) * P3"
"0","    B1 = (t2 - t) / (t2 - t0) * A1 + (t - t0) / (t2 - t0) * A2"
"0","    B2 = (t3 - t) / (t3 - t1) * A2 + (t - t1) / (t3 - t1) * A3"
"0","    "
"0","    points = (t2 - t) / (t2 - t1) * B1 + (t - t1) / (t2 - t1) * B2"
"0","    return points"
"0","    "
"0","def catmull_rom(points, res=100):"
"0","    """""""
"0","    Computes Catmull-Rom Spline for given support points and resolution."
"0","    Args:"
"0","        p: array of (x,y)-coords"
"0","        res: resolution of a segment (including the start point, but not the endpoint of the segment)"
"0","    Returns:"
"0","        (x,y): array"
"0","    """""""
"0","    point_quadruples = []"
"0","    for i in range(len(points)-1):"
"0","        if i == 0:"
"0","            # need to estimate an additional support point before the first"
"0","            point_quadruples.append([(points[0][0] - (points[1][0] - points[0][0]), points[0][1] - (points[1][1] - points[0][1])), (points[0][0], points[0][1]), (points[1][0], points[1][1]), (points[2][0], points[2][1])])"
"0","        elif i == len(points) - 2:"
"0","            # need to estimate an additional support point after the last"
"0","            point_quadruples.append([points[i-1], points[i], points[i+1], (points[i+1][0] + (points[i+1][0] - points[i][0]), points[i+1][1] + (points[i+1][1] - points[i][1]))])"
"0","        else:"
"0","            point_quadruples.append([points[i-1], points[i], points[i+1], points[i+2]])"
"0","    return np.concatenate([catmull_rom_one_point(*pq, res) for pq in point_quadruples])"
"0","    "
"0","def visualizeRoad(nodes):"
"0","    fig, ax = plt.subplots()"
"0","    for node in nodes:"
"0","        x = [n[0] for n in node]"
"0","        y = [n[1] for n in node]"
"0","        z = [n[2] for n in node]"
"0","        ax.plot(x, y)"
"0","    ax.set_xlabel('x')"
"0","    ax.set_ylabel('y')"
"0","    ax.set_title('roads')"
"0","    ax.set_aspect('equal')"
"0","    plt.show()"
"0","    fig, ax = plt.subplots(subplot_kw={""projection"": ""3d""})"
"0","    for node in nodes:"
"0","        x = [n[0] for n in node]"
"0","        y = [n[1] for n in node]"
"0","        z = [n[2] for n in node]"
"0","        ax.scatter(x,y,z)"
"0","    ax.set_xlabel('x')"
"0","    ax.set_ylabel('y')"
"0","    ax.set_zlabel('z')"
"0","    ax.set_title('roads')"
"0","    plt.show()"
"0","    "
"0","responseRoad = None"
"0",""
"0","def importRoad(scenario:Scenario, f:str=None, rfj:str=None, debug:bool=False):"
"0","    #scenario"
"0","    #   scenario instance"
"0","    #f"
"0","    #   string - folder"
"0","    #rfj"
"0","    #   string - road_file_json"
"0","    #debug"
"0","    #   bool - for debuging visualization of roads"
"0","    global responseRoad"
"0","    global folder"
"0","    global terrain_file_json"
"0","    if f == None:"
"0","        f = folder"
"0","    if rfj == None:"
"0","        rfj = road_file_json"
"0","    print(""Loading road data..."")"
"0","    #read json"
"0","    with open(os.path.join(f, rfj), ""r"") as file:"
"0","        responseRoad = json.load(file)"
"0","    #building roads"
"0","    nodes = [tuple([tuple([geometry[""lon""],geometry[""lat""],geometry[""height""]]) for geometry in element[""geometry""]]) for element in responseRoad[""elements""]]"
"0","    #roads = []"
"0","    #roads_mesh = []"
"0","    #for node in nodes:"
"0","    #    r = Road('track_editor_C_center')"
"0","    #    [r.add_nodes(n) for n in node]"
"0","    #    roads.append(r)"
"0","    #    rm = MeshRoad('track_editor_C_center')"
"0","    #    [rm.add_nodes(n) for n in node]"
"0","    #    roads_mesh.append(rm)"
"0","    #[scenario.add_road(road) for road in roads]"
"0","    #[scenario.add_mesh_road(road_mesh) for road_mesh in roads_mesh]"
"0","    if debug:"
"0","        visualizeRoad(nodes)"
"0","    #return scenario"
"0","    "
"0","folder = ""data/uniud"""
"0","road_file_json = ""road.json"""
"0",""
"0","importRoad(None, folder, road_file_json, False)"
"1","Loading road data...
"
"0","road1 = catmull_rom([(point['lon'], point['lat']) for point in [element for element in responseRoad['elements'] if element['id'] == 360575424][0]['geometry']], 100)"
"0","road1 = road1[::-1]"
"0","road2 = catmull_rom([(point['lon'], point['lat']) for point in [element for element in responseRoad['elements'] if element['id'] == 360575427][0]['geometry']], 100)"
"0","road2 = road2[::-1]"
"0","road3 = catmull_rom([(point['lon'], point['lat']) for point in [element for element in responseRoad['elements'] if element['id'] == 48852157][0]['geometry']], 100)"
"0","road3 = road3[::-1]"
"0",""
"0","road = np.concatenate((road1, road2, road3))"
"0",""
"0","l1 = len(road1)"
"0","l2 = len(road2)"
"0","l3 = len(road3)"
"0",""
"0","del road1"
"0","del road2"
"0","del road3"
"0",""
"0","distances_raw = []"
"0","roadid_raw = []"
"0","i = 0"
"0","for index, row in r.raw.iterrows():"
"0","    dist_min = float(""+Inf"")"
"0","    best_i = i"
"0","    count = 0"
"0","    while i < len(road):"
"0","        dist = np.sqrt((row[""position_x""] - road[i][0])**2 + (row[""position_y""] - road[i][1])**2)"
"0","        if dist < dist_min:"
"0","            dist_min = dist"
"0","            best_i = i"
"0","            count = 0"
"0","        else:"
"0","            count += 1"
"0","        if count >= 100:"
"0","            break"
"0","        i += 1"
"0","    distances_raw.append(dist_min)"
"0","    if best_i < l1:"
"0","      roadid_raw.append(1)"
"0","    elif best_i < l1+l2:"
"0","      roadid_raw.append(2)"
"0","    else:"
"0","      roadid_raw.append(3)"
"0","    i = max(best_i - 100, 0)"
"0","    "
"0","distances_custom = []"
"0","roadid_custom = []"
"0","i = 0"
"0","for index, row in r.custom.iterrows():"
"0","    dist_min = float(""+Inf"")"
"0","    best_i = i"
"0","    count = 0"
"0","    while i < len(road):"
"0","        dist = np.sqrt((row[""position_x""] - road[i][0])**2 + (row[""position_y""] - road[i][1])**2)"
"0","        if dist < dist_min:"
"0","            dist_min = dist"
"0","            best_i = i"
"0","            count = 0"
"0","        else:"
"0","            count += 1"
"0","        if count >= 100:"
"0","            break"
"0","        i += 1"
"0","    distances_custom.append(dist_min)"
"0","    if best_i < l1:"
"0","      roadid_custom.append(1)"
"0","    elif best_i < l1+l2:"
"0","      roadid_custom.append(2)"
"0","    else:"
"0","      roadid_custom.append(3)"
"0","    i = max(best_i - 100, 0)"
"0","    "
"0","distances_custom_elevation = []"
"0","roadid_custom_elevation = []"
"0","i = 0"
"0","for index, row in r.custom_elevation.iterrows():"
"0","    dist_min = float(""+Inf"")"
"0","    best_i = i"
"0","    count = 0"
"0","    while i < len(road):"
"0","        dist = np.sqrt((row[""position_x""] - road[i][0])**2 + (row[""position_y""] - road[i][1])**2)"
"0","        if dist < dist_min:"
"0","            dist_min = dist"
"0","            best_i = i"
"0","            count = 0"
"0","        else:"
"0","            count += 1"
"0","        if count >= 100:"
"0","            break"
"0","        i += 1"
"0","    distances_custom_elevation.append(dist_min)"
"0","    if best_i < l1:"
"0","      roadid_custom_elevation.append(1)"
"0","    elif best_i < l1+l2:"
"0","      roadid_custom_elevation.append(2)"
"0","    else:"
"0","      roadid_custom_elevation.append(3)"
"0","    i = max(best_i - 100, 0)"
"0","    "
"0",""
